Contexts
========
function -> expression  and YamlClassFunction
int/long/float/double/uint_64 -> expression
string -> expression
boolean -> expression
struct -> expression
object -> expression and YamlClassAttribute ... always with specific type
object_array -> expression



Parsing scalar values:
======================
function -> create new function
int/long/float/double/uint_64 -> evaluate as expr
string -> string
boolean -> boolean
object -> object



Parsing arrays:
===============
struct -> as struct fields interpreted
object_array -> as array interpreted (size_t size and Type buffer[size]) -> objects are flat and interpreted as structs



Parsing dicts:
==============
struct -> via make function -> check functions from up to bottom
object -> via init or make + via optional attributes -> check constructors from up to bottom
	the optional attributes must take no parameters in the constructor except one optional paramater "correspondingObject"





special keys: ref, extend

ref: create an attribute inside current class which references it.
extend: only allowed at first level. Extends all from this object.

custom keys:
- expand attributes of object for initialisation
- only use standard init or make function respectively
- parameters in make/init function of attributes are required, parameters in functions are optional


### Resource providers:
use an annotation to functions @provider.

1 kind of annotations:
@provider(NewType) ... map the function as a type for yaml
-> corresponding function has to take exactly one argument (const char *)



Data binding in scalar values:
==============================
expressions of the form $variableName will get binded. They have to be provided to the yaml view.
-> They will be provided via one struct, which includes all needed variables.


Type safety:
============
Check if type matches any super class. Delegates of the class shall not be checked and should result in an error.



Knackpunkt: provider konzept
============================


keys:
generate, template, type, resource, ref